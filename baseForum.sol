
// SPDX-License-Identifier: GPL-3.0
pragma solidity >=0.7.0 <0.10.0;

import "@openzeppelin/contracts/utils/Strings.sol";
/**
 * @title newWayToFormCommunitiesCollaborateOnProjectsAndJoinForcesToDefeatEvil
 * @dev This contract allows individuals to form communities, collaborate on projects, and work together to achieve a common goal. The contract includes functions for joining and leaving communities, as well as for posting updates about the progress of projects. It also includes a struct for storing information about each community, including the home page HTML, the name of the community, and a list of members.
 */

contract newWayToFormCommunitiesCollaborateOnProjectsAndJoinForcesToDefeatEvil {
    
    event emitString(string emission);
    // Struct to store information about a community
    struct Community {
        // What is the first impression this community wants to project?
        string homePageHTML;
        // The community needs to have a name, e.g "United States of America"
        string name;
        // An account of the members of the community
        mapping(address => Member) members;
        // Log of the results of the work done by community members
        uint communityBalance;
        // amount community requires members to deposit
        uint communityDeposit;
        uint totalPosts;
        string [] bannedWords;
    }
    // Struct to store information about a member
    struct Member {
        address addr;
        uint balance;
        uint privilegeLevel;
    }

    struct comment {
        string content;
        // mapping to ID of post being responded to or referenced.
        uint commentID;
        uint upvotes;
        uint downvotes;
    }
// TODO: Finish buidling and test nono word protocol, Comment total should match as comment ID so just can link back to what number ottal comment it is. 
    // Mapping to store information about each community
    mapping(string => Community) public communities;
    string [] communityNames;
    string [] contentArr;
    
    // Function to create a new community. Default homeVideoUrl and Image can be generated by AI
    function createCommunity(string calldata name, string calldata op) public payable{
        // require initial payment, community does not already exist, community purpose and name not empty
        require(msg.value > 10, "Not enough");
        require(communities[name].communityBalance == 0, "Community already exists");
        require(keccak256(abi.encodePacked(name)) != keccak256(abi.encodePacked("")), "Need a name!");
        require(keccak256(abi.encodePacked(op)) != keccak256(abi.encodePacked("")), "Need a purpose!");
        // TODO: Adjust how community governance works. Currently we have "privilige level". Need to allow for adjustment of privilige within the community.
        // Generates default HTML code for community. TODO: better way to do it would be through etherscan. Reads a contract to know what the code is and inputs the right stuff where it needs to.
        communities[name].homePageHTML = "|HTML|<h1>";
        communities[name].homePageHTML = string.concat(communities[name].homePageHTML, name);
        communities[name].homePageHTML = string.concat(communities[name].homePageHTML, "</h1><br>Purpose: <br>");
        communities[name].homePageHTML = string.concat(communities[name].homePageHTML, op);
        communities[name].homePageHTML = string.concat(communities[name].homePageHTML, "<br> Comments go here<br>");
        // Adds owner to list of members
        communities[name].members[msg.sender].addr = msg.sender;
        communities[name].members[msg.sender].balance = msg.value;
        communities[name].members[msg.sender].privilegeLevel = 2;
        // initializes community
        communities[name].communityBalance = msg.value;
        communities[name].name = name;
        communities[name].totalPosts = 1;
        communityNames.push(name);
        // TODO: CONTENT PUSH
        contentArr.push(communities[name].homePageHTML);
        emit emitString(string.concat(name, communities[name].homePageHTML));
    }
    // Function to join an existing community
    function joinCommunity(string calldata name) public payable {
        require(communities[name].communityBalance > 0, "Community does not exist");
        require(communities[name].members[msg.sender].addr != msg.sender, "User already member of community");
        require(msg.value > 10, "Need to provide community deposit");
        communities[name].members[msg.sender].addr = msg.sender;
        communities[name].members[msg.sender].balance = msg.value;
        communities[name].members[msg.sender].privilegeLevel = 1;
        // TODO: Emit user joined event so that way interface can display only communities address is a member of
        // TODO: Returns success! reading
    }
    //TODO: any community's governance token can be bought out for 10x what the owner paid for it
    // Function to leave a community
    function leaveCommunity(string calldata communityName) public {
        require(communities[communityName].communityBalance > 0, "Community does not exist");
        require(communities[communityName].members[msg.sender].addr == msg.sender, "User not member of community");
        // TODO: require that user did not say anything within the last 24 hours
        // resends the money they are owed back to them
        msg.sender.call{value: communities[communityName].members[msg.sender].balance}("");
        delete communities[communityName].members[msg.sender];
        // TODO: Emit user left event
        // Todo: success leaving returns
    }

    // Function to create a new comment in a community
    function postComment(string calldata communityName, uint responseID, string calldata content) public {
        require(communities[communityName].communityBalance > 0, "Community does not exist");
        require(communities[communityName].members[msg.sender].addr == msg.sender, "User not member of community");
        // Activates nonoWord protocol
        for(uint i = 0; i < nonoWords.length; i ++){
            if (keccak256(abi.encodePacked(content)) == keccak256(abi.encodePacked(nonoWords[i]))){
                // TODO: pay me!
                return;
            }
        }
        // add to comment total
        communities[communityName].totalPosts += 1;
        string memory emission = string.concat(communities[communityName].name, "|");
        emission = string.concat(emission, Strings.toString(responseID));
        emission = string.concat(emission, "|");
        emission = string.concat(emission, content);

        contentArr.push(emission);
        emit emitString(emission);

    }       
    string [] nonoWords = ["|", "nigg", "fuck", "shit", "bitch"];

    // Function to vote on a post in a community
    function upVoteComment(string calldata name, uint responseID) public {
        require(communities[name].communityBalance > 0, "Community does not exist");
        require(communities[name].totalPosts >= responseID);
        require(communities[name].members[msg.sender].balance > 10, "Only members can vote on comments");
        string memory newString = "|Post Interacted|";
        newString = string.concat(newString, Strings.toString(responseID));
        newString = string.concat(newString, "|");
        contentArr.push(string.concat(name, newString));
        emit emitString(string.concat(name, newString));
    }

    // Function to vote on a post in a community
    function downVoteComment(string calldata name, uint responseID) public {
        require(communities[name].communityBalance > 0, "Community does not exist");
        require(communities[name].totalPosts >= responseID, "Post not found");
        require(communities[name].members[msg.sender].balance > 10, "Only members can vote on comments");
        string memory newString = "|Post Interacted|";
        newString = string.concat(newString, Strings.toString(responseID));
        newString = string.concat(newString, "|");
        contentArr.push(string.concat(name, newString));
        emit emitString(string.concat(name, newString));
    }

    function editHTML(string calldata name, string calldata content) public {
        require (communities[name].members[msg.sender].privilegeLevel > 1, "Not the owner");
        communities[name].homePageHTML = content;
    }

    function addContent(string calldata name, string calldata content) public {
        require(bytes(content).length > 0, "Image content cannot be empty");
        require(communities[name].members[msg.sender].balance > 10, "Only members can add community image");
        string memory newString = string.concat(name, "|");
        newString = string.concat(newString, Strings.toString(communities[name].totalPosts));
        newString = string.concat(newString, "|");
        newString = string.concat(newString, content);
        // adds to comment total
        communities[name].totalPosts += 1;
        contentArr.push(newString);
        emit emitString(newString);
    }

    function comNames(string calldata name) public view returns(string [] memory content){
        return communityNames;
    }
    // TODO: Getter functions. Need to return: community html, all community posts with their ID's
    function contentDisplay() public view returns(string [] memory content){
        return contentArr;
    }
//TODO: figure out upvotes and downvotes
    function removeContent (uint index) public{
        delete contentArr[index];
    }
}
